_**VCS**_ (_**V**ersion **C**ontrol **S**ystem) с/с контроля версий 
**SCM** (_**S**ource **C**ontrol **M**anagement) с/с управления исходным кодом
помогает отслеживать изменения в программах, текстовых файлах, больших документах, веб-сайтах.
**ревизия** / **версия** - 1+ изменение. инф о том, что изменилось, кто внёс изменения, когда и иногда комментарии к изменению.
функции с/с контроля версий:
- хранит ист изменений в виде отдельных ревизий;
- позволяет манипулировать ист: менять порядок ревизий, удалять версии, возвращаться назад в ист;
- помогает анализировать изменения: кто и когда вносит изменения, кто чаще вносит изменения в определённый файл и тд.
Аналоги: Git, Mercurial, Subversion.
git «мерзавец».
В каких случаях использовать Git?
+ Для синхронизации изменений, сделанных разными участниками команды.
+ Чтобы хранить ист изменений файлов при командной работе.
+ Для хранения нескольких версий проекта, над которым работает один человек.
# командной строки
Командная строка - инструмент взаимодействия с компьютером.
У macOS / Linux командная строка установлена.
###  установка для Windows
для Windows **Git Bash** пакет **Git for Windows**. установит Bash и Git
1. [на эту страницу официального сайта Git](https://git-scm.com/download/win).
2. Скачай 1 из версий **Standalone Installer** («автономный установщик»). 
3. Запусти программу установки. Обратите внимание, куда б установлен Git. Обычно `C:\Program Files\Git`.
4. Проверь, что в списке устанавливаемых программ стоит галочка напротив пункта **Git Bash Here** — позволит открывать консоль с Git в любой папке.
5. установщик предложит мн опций. достаточно оставить все настройки по умолчанию. Несколько раз нажми **Next** («далее»), пока не начнётся установки.
6. После окончания установки нажми **Finish** («завершить»).
### Запуск Git Bash
1. ввести название программы в окно поиска на панели задач.
2. открыть директорию, в которую установлен Git. `C:\Program Files\Git\bin` запусти `bash.exe`.
# командной строкой
### Графический интерфейс vs командная строка
**графический интерфейс** (_**G**raphical **U**ser **I**nterface_, _GUI_). окна, значки, кнопки, выпадающее меню с настройками и прочие элементы.
**Командная строка** (_**C**ommand-**l**ine **I**nterface_, _CLI_) - интерфейс текстовый. Пользователь вводит в неё команды. Она принимает их от пользователя и выполняет.
Чтобы создать папку, нажимае ПКМ и выбираете пункт в графическом меню. это м сделать и ч/з командную строку - достаточно ввести соответствующую команду и имя папки.
**Командная строка/терминал/консоль**. Вводить данные или вызывать программы ч/з устройства: терминалы и консоли.
мн программы пишут в виде консольных приложений затем появляется графический интерфейс. у некоторых компьютеров, у серверов в центрах обработки данных, нет GUI. Консоль помогает взаимодействовать с ними.
### pwd
(_**p**rint **w**orking **d**irectory_ - «показать рабочую папку»). выводит путь к текущей директории.
**Домашняя директория** (_home directory_) - каталог с файлами пользователя. хранит загрузки, медиа, скриншоты. командную строку, оказываетесь в домашней директории.
Windows путь начинается с буквы диска C `/c/` или `c:/`
Linux нет букв дисков, домашняя директория в `/home`
macOS папка `/Users`, но нет букв дисков.
примеры м отличаться от того, что видите на компьютере.
`cd` (_**c**hange **d**irectory_ — «сменить директорию») и 
символ `~` обозначение домашней директории. `Enter` для выполнения.
# Навигация
Файловая с/с состоит из папок / директорий. В них мб папки и файлы Когда открываете папку ч/з графический интерфейс ОС видите её содержимое.
### Вывести содержимое директории - `ls`
(_**l**i**s**t directory contents_  «отобразить содержимое директории») отображения файлов и папок
### Сменить директорию - `cd`
(_**c**hange **d**irectory_ «сменить директорию»). меняет рабочую директорию на ту, которая в параметра: `cd имя_папки`.
==если в названии папки есть пробелы, при вводе использовать кавычки==
Чтобы вернуться в **родительскую директорию** - на ур выше, - вместо названия папки писать 2 точки: `..`
```BASH
$ pwd
/projects/github # сейчас мы здесь

$ cd .. # переход на уровень выше 
```
обратиться к текущей директории, использовать `.` для запуска программ, которые принимают папку в качестве параметра
cd` м перемещаться ч/з несколько директорий. раздели их названия знаком `/`
### Доп возможности `ls`
`ls` с флагом `-a` вывести расширенный список. отобразятся скрытые файлы, которые начинаются с символа `.` (например, файлы конфигурации). В том числе 2 особых файла `.` и `..`, которые обозначают текущую и родительскую директории.
```BASH
$ ls # вывели список файлов
file.txt
photo.png

$ ls -a # вывели список, в котором отображаются скрытые файлы ., .. и .git
.
..
.git
file.txt
photo.png 
```
м работать с символом домашней директории (`~`) и предыдущей директории (`..`)
`ls ~` выведет содержимое домашней директории
`ls ..` покажет содержимое родительской директории.
`ls -a` печатать содержимое директории со скрытыми файлами
`cd` Сменит текущую директорию
`pwd` Вывести на экран текущую рабочую директорию
### Создание файлов и директорий `touch`, `mkdir`
(«коснуться») с именем файла в параметра: `touch %ИМЯ_ФАЙЛА%`.
```BASH
$ touch my-new-file.txt # создали файл my-new-file.txt 
```
==при создании файла указывать расширение==
`mkdir` (_**m**a**k**e **dir**ectory_ «создать директорию»). Для создания директорий
```BASH
$ mkdir new-dir # создали директорию new-dir 
```
М создать стр-ру директорий 1 командой с помощью флага `-p`.
```BASH
$ mkdir -p dir1/dir-inside/dir-deeper-inside
# создали папку dir-deeper-inside в папке dir-inside, которая находится в папке dir1 
```
По умолчанию `touch` и `mkdir` создают файлы и папки в текущей рабочей директории. если вы в директории `abs`, `touch file.txt` создаст файл там: `abs/file.txt`.
м использовать обе команды вместе с символом домашней директории (`~`) / родительской директории (`..`)
`mkdir ~/my-git-projects` создаст папку `my-git-projects` вн домашней директории.
`touch ../../file.txt` создаст `file.txt` на 2 папки выше по иерархии. если вы в директории `projects/git/hello`, команда `touch ../../file.txt` создаст файл по такому пути: `projects/file.txt`
### Копирование файлов - `cp`
(_**c**o**p**y_ «копировать»). 2 параметра: `что копируем` и `куда копируем`.
```BASH
$ cp index.html src/
# скопировали index.html в папку src 
```
м указать сразу несколько файлов.
```BASH
$ cp index.html style.css script.js src/
# скопировали 3 файла (index.html, style.css и script.js) в папку src 
```
создай папку `first-project` Вн создай: `data.txt` и `table.csv`.
```BASH
$ mkdir first-project   
$ touch first-project/data.txt first-project/table.csv 
```
## Перемещение файлов и папок - `mv`
**(_m**o**v**e_ «переместить»)
Синтаксис аналогичен `cp`. После имени команды список файлов и папок, которые нужно переместить, затем - папку, в которую перемещение.
```BASH
$ mv table.csv ./very-important-files
# указываем имя файла, который хотим переместить, потом путь — куда перемещаем 

$ cd very-important-files
$ ls
table.csv 
# перешли в папку very-important-files и проверили, что всё сработало 
```
### Чтение файлов - `cat`
(c_on**cat**enate and print_ «объединить и распечатать») вместе с именем файла. распечатает то, что содержится в нём.
```BASH
$ cat myfile.txt # распечатали содержимое файла myfile.txt
file-content-1
file-content-2 
```
==работает только с текстовыми файлами==
### Удаление файлов и папок - `rm`, `rmdir`, `rm -r`
`rm` (_**r**e**m**ove  «удалить»_) и передать ей имя файла.
```BASH
$ rm example.txt # удалил example.txt из текущей папки 
```
`rmdir` (_**r**e**m**ove **dir**ectory «удалить директорию»_). указать имя папки.
```BASH
$ rmdir images # команда удалит папку images из текущей директории, 
               # если папка images пуста 
```
Если в папке, которую пытаетесь стереть, есть файлы, то командная строка не удалит её и выведет сообщение о том, что папка не пуста (`Directory not empty`).
защита от случайного удаления. Если папку нужно удалить с содержимым, м использовать команду `rm`
```BASH
$ rm -r images # удалили папку images со всем её содержимым из текущей директории 
```
`rm -r` (`-r` _**r**ecursive_, «рекурсивный») **рекурсивно** удаляет файлы и папки. удаление б последовательно применяться к каждому из элементов в папке - пока не сотрёт все. Затем удалит пустую директорию. удаление командами `rm` и `rmdir` необратимо - файлы и папки не попадают в корзину и исчезают навсегда.
### Выполняй несколько команд
Команды м указывать списком. их нужно разделить (`&&`).
```BASH
$ mkdir second-project && cd second-project && touch index.html style.css
# создаём папку second-project,
# переходим в папку second-project
# и создаём в ней два файла: index.html и style.css 
``````
### Вызывай команды из буфера
 **буфер** (_buffer_ — «посредник») память терминала. хранят команды, которые вызывались до этого. Чтобы обратиться к последней введённой команде, стрелку вверх (**`↑`**). Если нажать ещё раз, предпоследняя команда; Чтобы вернуться стрелку вниз (**`↓`**).
### Автозаполнение
Необязательно заучивать команды. набрать 1ю букву и дважды нажать `Tab`. покажет список всех команд, которые начинаются с этих символов.
`Tab` дописывает команды и пути.
Если есть несколько файлов / папок, которые начинаются так же. Нажми `Tab` ещё раз, и увидите их список.
```BASH
$ cd U[Tab] # ввели 1ю букву имени пользователя и нажал Tab
# имя папки Username подставится автоматически 

$ cd ~/[Tab] # вывели список директорий, чтобы понять, куда переходить
Applications/  Downloads/     Library/       Parallels/     Public/        diagrams/      memes/         python/
Desktop/       Dropbox/       Movies/        Pictures/      bin/           docs/          papers/        tmp/
Documents/     Exercism/      Music/         Postman/       books/         go/            projects/ 
```
Если вывод большой, консоль спросит, нужно ли показать все варианты.
```BASH
$ cd ~/[Tab] 
zsh: do you wish to see all 426 possibilities (429 lines)? # точно хотите увидеть все 426 варианта (429 линий)? 
```
Чтобы подтвердить вывод, нажать `y`, чтобы отменить - `n`.
### Команды быстрой навигации
- `pwd` — проверить, где находимся;
- `ls` — посмотреть список файлов/папок в директории;
- `cd` — перейти в выбранную папку.
м почти мгновенно перемещаться в ключевые папки. вы хотите увидеть содержимое **корневой директории** (_root directory_). верхняя в иерархии папка, в которой хранится всё, на вашем жёстком диске. действия зависят от типа ОС. на macOS / Linux, напечатай слеш (`/`) и 2 нажмите `Tab`.
```BASH
/
Applications/            Network/                 Library/                   
System/                  Volumes/                 Users/

# содержимое корневой директории macOS 
```
В терминале напечаталось содержимое корневой директории.
В эту директорию м быстро перемещаться с помощью `cd /` + `Enter`
```BASH
$ cd / # перемещает в корневую директорию 
```
Чтобы попасть в корневую директорию Windows `cd c:/` + `Enter` или `cd /c` + `Enter`.
```BASH
$ cd c:/ # переместились в корневую директорию
$ ls
Documents and Settings/     Windows/
Program Files/              Users/
Program Files (x86)/
```
macOS и Linux основаны на UNIX, Windows отдельная ОС.
«тильда» (`~`) хранит ссылку на домашнюю директорию. чтобы переместиться в неё, напечатать `~` и нажать `Enter`.
```BASH
$ cd ~
$ pwd 
/Users/Username
$ cd ~/Documents # папка Documents хранится в домашней директории
$ pwd
/Users/Username/Documents 
```
## Настройка
Чтобы участникам проекта б понятно, кто и какие изменения вносил, нужно указать имя и почту.
команда `git config` (_configuration_ «настройка») с ключом `--global` («глобальный»). не имеет значения, в какой директории находитесь
В качестве значения `user.name` указать своё имя / никнейм. Для настройки параметра `user.email` указывают электронную почту.
```BASH
$ git config --global user.name "User Namovich" 
# имя или ник нужно написать латиницей и в кавычках

$ git config --global user.email username@yandex.ru
# здесь нужно указать свой настоящий email 
```
глобальные настройки хранит в файле `.gitconfig` в домашней директории. Команда запишет в этот файл имя и почту. Чтобы убедиться в этом, вызвать команду для чтения файлов.
```BASH
$ cat ~/.gitconfig 
```
2й способ проверки вывести содержимое файла конфигурации Git командой `git config` с флагом `--list` («список»).
```BASH
$ git config --list 
```
командная строка покажет текущие значения настроек.
```BASH
user.name=Username
user.email=username@yandex.ru 
```
### Навигация
- `pwd` (_**p**rint **w**orking **d**irectory_, «показать рабочую папку»)  покажи, в какой я папке;
- `ls` (_**l**i**s**t directory contents_, «отобразить содержимое директории») покажи файлы и папки в текущей папке;
- `ls -a` покажи также скрытые файлы и папки, названия которых начинаются с `.`;
- `cd first-project` (_**c**hange **d**irectory_, «сменить директорию») перейди в папку `first-project`;
- `cd first-project/html` перейди в папку `html`, которая находится в папке `first-project`;
- `cd ..` перейди на ур выше, в родительскую папку;
- `cd ~` перейди в домашнюю директорию (`/Users/Username`);
- `cd /` перейди в корневую директорию.
### Работа с файлами и папками
**Создание**
- `touch index.html` (_touch,_ «коснуться») создай файл `index.html` в текущей папке;
- `touch index.html style.css script.js` создать сразу несколько файлов, печатать их имена в 1 строку ч/з пробел;
- `mkdir second-project` (_**m**a**k**e **dir**ectory_, «создать директорию») создай папку с именем `second-project` в текущей папке.
**Копирование и перемещение**
- `cp file.txt ~/my-dir` (_**c**o**p**y_, «копировать») скопируй файл в др место;
- `mv file.txt ~/my-dir` (_**m**o**v**e_, «переместить») перемести файл / папку в др место.
**Чтение**
- `cat file.txt` (_con**cat**enate and print_, «объединить и распечатать») распечатай содержимое текстового файла `file.txt`.
**Удаление**
- `rm about.html` (_**r**e**m**ove_, «удалить») удали `about.html`;
- `rmdir images` (_**r**e**m**ove **dir**ectory_, «удалить директорию») удали папку `images`;
- `rm -r second-project` (_**r**e**m**ove,_ «удалить» + _**r**ecursive_, «рекурсивный») удали папку `second-project` и всё, что она содержит.
### Полезные возможности
- м указать команды списком разделить 2 амперсандами (`&&`).
- У консоли есть память буфер с последними командами. По ним м перемещаться с помощью стрелки вверх (**`↑`**) и вниз (**`↓`**).
- Чтобы не вводить название файла / папки полностью, м набрать 1е символы имени и 2 нажать `Tab`. Если файл / папка есть в директории, командная строка допишет путь сама.
# Инициализируем репозиторий
### Сделать папку репозиторием - `git init`
Чтобы Git начал отслеживать изменения в проекте, папку с файлами проекта нужно сделать **Git-репозиторием** (_repository_ «хранилище»). переместиться в неё и ввести `git init` (_**init**ialize_ «инициализировать»).
создай папку `first-project` и сделай её Git-репозиторием: перейди в неё с помощью команды `cd` и выполни `git init`.
```BASH
$ cd ~/dev/first-project # перешли в нужную папку
$ git init # создали репозиторий 
```
м создать папку в любом месте. не забывай менять в примерах путь `~/dev/first-project` на тот, который ведёт к папке.
не создавать репозиторий Git вн др Git-репозитория. м вызывать проблемы с отслеживанием изменений.
при инициализации репозитория Git м показать сообщение, которое начинается `Using 'master' as the name…`
В зависимости от настроек Git м назвать начальную ветку `main`/ `master`. Сообщение появится если ветка по умолчанию `master`.
**master** «хозяин», рекомендуется называть осн ветку `main` («главная»).
`git init` выведет сообщение вида `Initialized empty Git repository in <ваша папка с проектом>/.git/` («инициализирован пустой Git-репозиторий в `<ваша папка>/.git/`»). В подпапке `.git` Git б хранить всю служебную инф.
`git init` редко применяемых, репозиторий создаётся 1 раз
### «Разгитить» папку `rm -rf .git`
Если сделали Git-репозиторием не ту папку, её м «разгитить». удали скрытую подпапку `.git`.
```BASH
$ cd <папка с репозиторием> # перешли в папку

$ rm -rf .git # удалили подпапку .git 
```
-  `-r` (_**r**ecursive_ «рекурсивно») удалять папки с содержимым;
-  `-f` (_**f**orce_ «заставить») избавит от вопросов «Вы точно хотите удалить этот файл? А этот? И этот тоже?».
==в подпапке `.git` ист изменений. Если удалить `.git`, ист проекта б стёрта без восстановления останется только последняя версия файлов/==
### Проверить состояние репозитория `git status`
(_status_, «статус», «состояние») показывает текущее состояние
`git status` выведет:
- название текущей ветки: `On branch master` / `On branch main`;
- сообщение о том, что в репозитории нет коммитов: `No commits yet`;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (зафиксировать), нужно сначала это создать» `nothing to commit (create/copy files and use "git add" to track)`.
В непонятной ситуации смотри состояние репозитория
# Добавляем файлы в репозиторий
### Подготовить файлы к сохранению `git add`
Чаще в Git хранят исходный код программ. с точки зрения с/с контроля версий любой код - текстовый файл. спец логики для хранения программ нет. Git мб повседневным инструментом разработчиков и технических писателей, создают документацию.
В примерах б использовать текстовые файлы, вместо них мб файлы с кодом.
Добавим в репозиторий `todo.txt` со списком дел и `readme.txt` с инф о проекте.
Создай файлы `todo.txt` и `readme.txt` в `first-project` и запусти `git status`, чтобы посмотреть, что изменилось.
```BASH
$ touch todo.txt
$ touch readme.txt
# создали файлы todo.txt и readme.txt
$ git status # проверили статус 
```
в `first-project` есть `untracked files` (_track_ «следить», _untracked_ «неотслеженный», «неотслеживаемый») ещё не отслеживаемые файлы `readme.txt` и `todo.txt`.
`untracked` = Git ещё не хранит инф о версиях файла и не м отследить, как он изменялся.
в `first-project` 2 файла. Мы хотим отслеживать состояние обоих, м использовать `git add --all` (_add_ «добавить» + _all_ «всё»). `--all` позволяет подготовить к сохранению все файлы в репозитории.
```BASH
$ git add --all # подготовили к сохранению все файлы в репозитории
$ git status # проверили статус 
```
Добавлять файлы м и по 1, без ключа `--all`.
```BASH
$ git add todo.txt
$ git add readme.txt
$ git status 
```
м добавить текущую папку целиком - все файлы в ней тоже б добавлены. Обратиться к текущей папке в Bash позволяет точка (`.`).
```BASH
$ git add . # добавить всю текущую папку
$ git status 
```
м использовать любой из этих вариантов - результат одинаковый.
Файлы, отмечены зелёным, отслеживаются и готовы к сохранению. сохранения пока не произошло, `git add` только запоминает текущее содержимое (контент) файла не сохраняет содержимое файлов в репозитории. 
**коммит** (_commit_ «совершать», «фиксировать») сохранение / фиксацию состояния файлов
«Сделать коммит» = сохранить текущую версию файла.
`git add` = добавление товаров в корзину в интернет-магазине,
коммит = оформление и оплатой заказа.
Если отредактировать любой из «зелёных» файлов, он перейдёт в состояние `modified` («изменённый») и б и в «зелёном», и в «красном» списках.
открой файл `todo.txt` в редакторе и напишите в нём: `1. Пройти пару уроков по Git.`
Сохрани изменения, затем вызови `git status`
`todo.txt` теперь есть и в «зелёном», и в «красном» списках:
- зелёным отмечена пустая версия файла - в таком виде он б во время последнего запуска команды `git add`;
- красным отмечена версия с текстом `1. Пройти пару уроков по Git.`
Чтобы запомнить новое состояние файла, нужно ввести `git add` и передать в качестве параметра имя изменённого файла / `--all`.
```BASH
$ git add todo.txt
# или
$ git add --all 
```
# Делаем коммит
Коммит гарантирует, что изменения б сохранены в ист и при необходимости к ним мб «откатиться».
### Выполнить коммит `git commit`
`git commit` `-m` (_**m**essage_ «сообщение»), присваивает коммиту сообщение. поясняет, в чём состояли изменения. как заметки на полях: благодаря им проще читать и понимать текст. Сообщение коммита улучшает понимание и упрощает навигацию. пишется после ключа `-m` в кавычках.
перейди в папку `first-project` и выполни коммит с комментарием
```BASH
$ git commit -m 'Мой первый коммит!' 
```
После `Enter` текущая версия файлов б сохранена в репозитории с сообщением `Мой первый коммит!`. **Коммит** (по названию команды `git commit`) - по сути список файлов с их контентом.
`git commit` выведет информацию о коммите.
- `[master (root-commit) baa3b6e]`:
    - коммит б в ветке `master`;
    - `root-commit` —  1й / «корневой» (_root_), коммит в ветке, у следующих коммитов такой надписи нет;
    - `baa3b6e` — сокращённый идентификатор коммита.
- `2 files changed, 1 insertion(+)`:
    - изменились 2 файла (`readme.txt` и `todo.txt`);
    - 1 строка б добавлена (`1. Пройти пару уроков по Git.`).
- Строки вида `create mode 100644 readme.txt` - более подробная инф о новых (добавленных в Git) файлах.
    - `create` («создать») файл б создан. Если бы файл б удалён, б бы `delete` («удалить»).
    - `mode 100644` это обычный файл. вариант `100755` для исполняемых файлов (например, `что-нибудь.exe`) и `120000` для файлов-ссылок в Linux. Файлы-ссылки не содержат данных сами по себе, а ссылаются на др файлы как «ярлыки» в Windows.
==после того как сделали 1й коммит, `git status` перестала выводить сообщение `No commits yet` («ещё нет коммитов»).==
### разница м/д `git add` и `git commit`
Сначала `git add` сообщает Git, какие файлы нужно сохранить и какую их версию. Затем с помощью `git commit` происходит сохранение
Сначала просите друзей стать в ряд - `git add`.
После того, как все заняли места, поправили волосы и улыбнулись, нажимаете кнопку и делаете снимок - `git commit`.
снимок - коммит. с обратной стороны подпись «Мой первый коммит!».
==Коммит описывать так, чтобы б понятно, какие изменения сделаны. `Добавлено важное дело в TODO`, `Добавлена сортировка имён` / `Исправлена ошибка в цикле`.==
добавить запись в `todo.txt` и зафиксировать изменения.
Отредактировать `todo.txt`
`git add todo.txt`
`git commit -m '<описание>'`
### Просмотреть ист коммитов `git log`
(_log_ «журнал [записей]»).
==по умолчанию `git log` выводит коммиты в обратном хронологическом порядке последние первыми сверху.==
Если в репозитории есть только 1 коммит / нет, вернитесь к прошлому уроку и убедитесь, что `git add` и `git commit` б вызваны в нужном порядке.
посмотри на ист коммитов. Выберите ту, в которой разработчик исправил больше ошибок / **багов** (_bug_ «жук»).
### Инициализация репозитория
`git init` ( _**init**ialize_, «инициализировать») инициализируй репозиторий.
### Подготовка файла к коммиту
`git add todo.txt` (_add_, «добавить») подготовь файл `todo.txt` к коммиту;
`git add --all` (_add_, «добавить» + _all_, «всё») подготовь к коммиту все файлы, в которых б изменения, и все новые файлы;
`git add .` подготовь к коммиту текущую папку и все файлы в ней.
### Создание коммита
`git commit -m "Комментарий к коммиту."` (_commit,_ «совершать», «фиксировать» + _**m**essage,_ «сообщение») сделай коммит и оставь комментарий, чтобы б проще понять, какие изменения внесены.
### Просмотр инф о коммитах
`git log` (_log_, «журнал [записей]») выведи ист коммитов.
### Просмотр состояния файлов
`git status` (_status_, «статус», «состояние») покажи текущее состояние репозитория.